/*
 * Copyright (c) 2002, 2003 Magnus Lind.
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software, alter it and re-
 * distribute it freely for any non-commercial, non-profit purpose subject to
 * the following restrictions:
 *
 *   1. The origin of this software must not be misrepresented; you must not
 *   claim that you wrote the original software. If you use this software in a
 *   product, an acknowledgment in the product documentation would be
 *   appreciated but is not required.
 *
 *   2. Altered source versions must be plainly marked as such, and must not
 *   be misrepresented as being the original software.
 *
 *   3. This notice may not be removed or altered from any distribution.
 *
 *   4. The names of this software and/or it's copyright holders may not be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "log.h"
#include "getflag.h"
#include "membuf.h"
#include "membuf_io.h"
#include "exo_helper.h"

static
void print_license()
{
    LOG(LOG_BRIEF,
        ("----------------------------------------------------------------------------\n"
         "Exoraw v1.0, Copyright (c) 2002 - 2005 Magnus Lind. (magli143@comhem.se)\n"
         "----------------------------------------------------------------------------\n"));
    LOG(LOG_BRIEF,
        ("This software is provided 'as-is', without any express or implied warranty.\n"
         "In no event will the authors be held liable for any damages arising from\n"
         "the use of this software.\n"
         "Permission is granted to anyone to use this software, alter it and re-\n"
         "distribute it freely for any non-commercial, non-profit purpose subject to\n"
         "the following restrictions:\n\n"));
    LOG(LOG_BRIEF,
        ("   1.  The origin of this software must not be misrepresented; you must not\n"
         "   claim that you wrote the original software. If you use this software in a\n"
         "   product, an acknowledgment in the product documentation would be\n"
         "   appreciated but is not required.\n"
         "   2. Altered source versions must be plainly marked as such, and must not\n"
         "   be misrepresented as being the original software.\n"
         "   3. This notice may not be removed or altered from any distribution.\n"));
    LOG(LOG_BRIEF,
        ("   4. The names of this software and/or it's copyright holders may not be\n"
         "   used to endorse or promote products derived from this software without\n"
         "   specific prior written permission.\n"
         "----------------------------------------------------------------------------\n"
         "The files processed and/or generated by using this software are not covered\n"
         "nor affected by this license in any way.\n"));
}

static
void print_usage(const char *appl, enum log_level level)
{
    const char *applp;

    /* strip pathprefix from appl */
    applp = strrchr(appl, '\\');
    if (applp != NULL)
    {
        appl = applp + 1;
    }                           /* done */
    applp = strrchr(appl, '/');
    if (applp != NULL)
    {
        appl = applp + 1;
    }
    /* done */
    LOG(level, ("usage: %s [option]... infile...\n", appl));
    LOG(level,
        ("  -o <outname> sets the outfile name, default is \"a.out\"\n"
         "  -q           enable quiet mode, display output is reduced to one line\n"
         "  -e <encoding> uses the given encoding\n"
         "  -b           crunch backwards"
         "  -d           decrunch mode"));
    LOG(level,
        ("  -m <offset>  limits the maximum offset size\n"
         "  -p <passes>  limits the maximum number of optimization passes\n"
         "  --           treat all args to the right as non-options\n"
         "  -?           displays this help screen\n"
         "  -v           displays version and the usage license\n"
         " All infiles are merged into the outfile. They are loaded in the order\n"
         " they are given on the command-line, from left to right.\n"));
}

int
main(int argc, char *argv[])
{
    const char *outfile = "a.out";
    const char *exported_encoding = NULL;
    int decrunch_mode = 0;
    int backwards_mode = 0;
    int c, infilec;
    char **infilev;
    int max_offset = 65536;
    int max_passes = 65536;

    struct membuf inbuf[1];
    struct membuf outbuf[1];

    /* init logging */
    LOG_INIT_CONSOLE(LOG_NORMAL);

    LOG(LOG_DUMP, ("flagind %d\n", flagind));
    while ((c = getflag(argc, argv, "bm:qo:vp:e:d")) != -1)
    {
        LOG(LOG_DUMP, (" flagind %d flagopt '%c'\n", flagind, c));
        switch (c)
        {
        case 'd':
            decrunch_mode = 1;
            break;
        case 'b':
            backwards_mode = 1;
            break;
        case 'q':
            LOG_SET_LEVEL(LOG_BRIEF);
            break;
        case 'm':
            if (str_to_int(flagarg, &max_offset) != 0 ||
                max_offset < 0 || max_offset >= 65536)
            {
                LOG(LOG_ERROR,
                    ("error: invalid offset for -m option, "
                     "must be in the range of [0 - 0xffff]\n"));
                print_usage(argv[0], LOG_NORMAL);
                exit(-1);
            }
            break;
        case 'p':
            if (str_to_int(flagarg, &max_passes) != 0 ||
                max_passes < 1 || max_passes >= 65536)
            {
                LOG(LOG_ERROR,
                    ("error: invalid value for -p option, "
                     "must be in the range of [1 - 0xffff]\n"));
                print_usage(argv[0], LOG_NORMAL);
                exit(-1);
            }
            break;
        case 'o':
            outfile = flagarg;
            break;
        case 'v':
            print_license();
            exit(0);
        case 'e':
            exported_encoding = flagarg;
            break;
        default:
            if (flagflag != '?')
            {
                LOG(LOG_ERROR,
                    ("error, invalid option \"-%c\"", flagflag));
                if (flagarg != NULL)
                {
                    LOG(LOG_ERROR, (" with argument \"%s\"", flagarg));
                }
                LOG(LOG_ERROR, ("\n"));
            }
            print_usage(argv[0], LOG_BRIEF);
            exit(0);
        }
    }
#if 0
    LOG(LOG_DEBUG, ("flagind %d\n", flagind));
    for (c = 0; c < argc; ++c)
    {
        if (c == flagind)
        {
            LOG(LOG_DEBUG, ("-----------------------\n"));
        }
        LOG(LOG_DEBUG, ("argv[%d] = \"%s\"\n", c, argv[c]));
    }
    exit(1);
#endif

    infilev = argv + flagind;
    infilec = argc - flagind;

    if (infilec != 1)
    {
        LOG(LOG_ERROR, ("error: zero or more than one input file.\n"));
        print_usage(argv[0], LOG_NORMAL);
        exit(-1);
    }

    membuf_init(inbuf);
    membuf_init(outbuf);

    read_file(infilev[0], inbuf);

    if(decrunch_mode)
    {
        int seems_backward = 0;
        int seems_forward = 0;
        unsigned char *p;

        p = membuf_get(inbuf);
        if(p[0] == 0x80 && p[1] == 0x0)
        {
            seems_backward = 1;
        }
        p += membuf_memlen(inbuf);
        if(p[-1] == 0x80 && p[-2] == 0x0)
        {
            seems_forward = 1;
        }

        // do we know what way it was crunched?
        if((seems_backward ^ seems_forward) != 0)
        {
            // yes, override option.
            backwards_mode = seems_backward;
        }

        if(backwards_mode)
        {
            LOG(LOG_NORMAL, ("Decrunching infile \"%s\" to outfile \"%s\" "
                             " backwards.\n", infilev[0], outfile));
            decrunch_backwards(LOG_NORMAL, inbuf, outbuf);
        }
        else
        {
            LOG(LOG_NORMAL, ("Decrunching infile \"%s\" to outfile \"%s\".\n",
                             infilev[0], outfile));
            decrunch(LOG_NORMAL, inbuf, outbuf);
        }
    }
    else
    {
        if(backwards_mode)
        {
            LOG(LOG_NORMAL, ("Crunching infile \"%s\" to outfile \"%s\" "
                             "backwards.\n", infilev[0], outfile));
            crunch_backwards(inbuf, outbuf, exported_encoding,
                             max_passes, max_offset);
        }
        else
        {
            LOG(LOG_NORMAL, ("Crunching infile \"%s\" to outfile \"%s\".\n",
                             infilev[0], outfile));
            crunch(inbuf, outbuf, exported_encoding, max_passes, max_offset);
        }
    }

    write_file(outfile, outbuf);

    membuf_free(outbuf);
    membuf_free(inbuf);

    LOG_FREE;

    return 0;
}
